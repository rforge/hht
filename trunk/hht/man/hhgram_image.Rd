\name{hhgram_image}
\alias{hhgram_image}
\title{Display Hilbert spectrogram}
\description{This function displays the Hilbert spectrogram of EMD and EEMD results.}
\usage{
hhgram_image(hgram, time_span = NULL, freq_span = NULL, amp_span = NULL, 
    clustergram = FALSE, cluster_span = NULL, imf_list = NULL, 
    fit_line = FALSE, scaling = "none", grid = TRUE, colorbar = TRUE, 
    backcol = c(0, 0, 0), colormap = NULL, pretty = FALSE, ...)
}
\arguments{
\item{hgram}{Data structure generated by \code{\link{hh_render}}.}
\item{time_span}{Time span to render spectrogram over.  \code{NULL} will draw the spectrogram over the entire signal.}
\item{freq_span}{Frequency span to render spectrogram over.  \code{NULL} plots everything up to the max frequency set when \code{\link{hh_render}} was run.}
\item{amp_span}{This is the amplitude span to plot, everything below is set to \code{backcol}, everything above is set to max color, \code{NULL} scales to the range in the signal.}
\item{clustergram}{If \code{TRUE}, plot the number of times data occupies a given pixel instead of plotting the signal amplitude.
This is akin to the \code{weight} component returned by the \code{as.image} function in the \code{fields} package.
Only applies when using EEMD.
Default is \code{FALSE}.}
\item{cluster_span}{Plots only parts of the signal that have a certain number of data points per pixel (see notes below).  
This only applies when using EEMD.  
The pixel range is defined as \code{c(AT LEAST, AT MOST)}.}
\item{imf_list}{A vector of IMFs to plot on the spectrogram, the others will not be shown.
You must set \code{combine_imfs = FALSE} in \code{\link{hh_render}} for this to work correctly.}
\item{fit_line}{If \code{TRUE}, plot a red line on the trace that shows the part of the signal represented by the spectrogram}.
\item{scaling}{determines whether to apply a logarithmic (\code{"log"}), or square root (\code{"sqrt"}) scaling to the amplitude data, default is \code{"none"}}
\item{grid}{Boolean - whether to display grid lines or not}
\item{colorbar}{Boolean - whether to display amplitude colorbar or not}
\item{backcol}{What background color to use behind the spectrogram, in a 3 element vector: \code{c(red, green, blue)}}
\item{colormap}{What palette object to use for the spectrogram, defaults to \code{rainbow}}
\item{pretty}{Boolean - to choose nice axes values or to use exactly the ranges given}
\item{\dots}{This function supports some optional parameters as well:
\itemize{
    \item{trace_format}{ - the format of the trace minima and maxima in sprintf format}
    \item{img_x_format}{ - the format of the X axis labels of the image in sprintf format}
    \item{img_y_format}{ - the format of the Y axis labels of the image in sprintf format}
    \item{colorbar_format}{ - the format of the colorbar labels in sprintf format}
    \item{cex.lab}{ - the font size of the image axis labels}
    \item{cex.colorbar}{ - the font size of the colorbar}
    \item{cex.trace}{ - the font size of the trace axis labels}
    \item{img_x_lab}{ - the X - axis label of the image, it defaults to "time"}
    \item{img_y_lab}{ - the Y - axis label of the image, it defaults to "frequency"}
    \item{main}{ - adds a title to the figure}}}
}

\details{
This function plots the image generated by \code{\link{hh_render}} along with the original signal trace.
The plotter can use data from both EMD and EEMD runs.
When it plots EEMD data, it shows the timefrequency plot of every single trial at once.
The \code{cluster_span} option is useful in this case because it can distinguish ``signal'' (pixels where multiple trials intersect) from ``noise'' (whether from EEMD or from nature) where only one trial contributes data.
}

\value{
\item{img}{The spectrogram image, suitable for plotting with the generic \code{image} function}
}

\note{
Using the option \code{combine_imfs = FALSE} in \code{\link{hh_render}} will cause \code{hhgram_image} to run much, much slower.
Unless you have a compelling reason to plot certain IMFs (as opposed to all of them combined), I recommend against using this.

It may take some trial and error to get a nice image.
For example, if the data points are too small (and thus the spectrogram looks like a mist of fine points rather than continuous frequency bands), try rerunning \code{\link{hh_render}}, but with lower frequency resolution.
If the spectrogram is extremely noisy, try defining \code{cluster_span} - this usually gets rid of most of the random noise.
For example, a \code{cluster_span} of \code{c(3, 10)} only keeps pixels that have data from at least 3 trials, up to 10.  
Most noise pixels will only have one trial contributing data. 
The upper limit (10) is a formality - it does not make much sense at this point to put an upper limit on trial intersections unless you are interested in the \bold{noise} component isolated from the signal.
}

\author{Daniel Bowman \email{daniel.bowman@unc.edu}}

\seealso{
\code{\link{ftgram_image}}, \code{\link{hh_render}}, \code{\link{hhspec_plot}}
}
\examples{
data(port_foster_event)

trials <- 10
nimf <- 10
noise_amp <- 6.4e-07
trials_dir <- "test"

set.seed(628)
#Run EEMD (this may take some time)
\dontrun{eemd(sig, tt, noise_amp, trials, nimf, trials_dir = trials_dir)}

#Compile the results
\dontrun{eemd_result <- eemd_compile(trials_dir, trials, nimf)}

#Calculate spectrogram
dt  <-  0.1
dfreq  <-  0.1
\dontrun{hgram <- hh_render(eemd_result, dt, dfreq)}


#Plot spectrogram 
time_span <- c(4, 10)
freq_span <- c(0, 25)
\dontrun{hhgram_image(hgram, time_span, freq_span,  
pretty = TRUE, img_x_format = "\%.1f", img_y_format = "\%.0f", 
main = "Port Foster event - ensemble Hilbert spectrogram")}

#Plot intersections

\dontrun{hhgram_image(hgram, time_span, freq_span, amp_span = c(1, 5),  
clustergram = TRUE, pretty = TRUE, img_x_format = "\%.1f", colorbar_format = "\%.0f",
img_y_format = "\%.0f", main = "Port Foster event - signal stability")}

#Decluster
#show only areas with stable signal 
#i.e. each pixel has data from at least 3 EEMD trials
\dontrun{hhgram_image(hgram, time_span = time_span, freq_span = freq_span,
cluster_span = c(, 10), pretty = TRUE, img_x_format = "\%.1f", 
img_y_format = "\%.0f",
main = "Port Foster event - ensemble Hilbert spectrogram")}

#Log amplitude plot

\dontrun{hhgram_image(hgram, time_span = time_span, freq_span = freq_span,
scaling = "log", pretty = TRUE, img_x_format = "\%.1f", img_y_format = "\%.0f",
main = "Port Foster event - ensemble Hilbert spectrogram with log amplitude")}

#Log frequency plot
dfreq <- 0.001
\dontrun{hgram=hh_render(eemd_result, dt, dfreq, scaling = "log")}
\dontrun{hhgram_image(hgram, time_span, freq_span = c(0, 2),          
pretty = TRUE, img_x_format = "\%.1f", img_y_format = "\%.2f",
img_y_lab = "log frequency",
main = "Port Foster event - ensemble Hilbert spectrogram with log frequency")}

#Only show IMF 1
dfreq <- 0.1
\dontrun{hgram=hh_render(eemd_result, dt, dfreq, combine_imfs = FALSE)}
\dontrun{hhgram_image(hgram, time_span, freq_span, imf_list = 1,
pretty = TRUE, img_x_format = "\%.1f", img_y_format = "\%.0f",
main = "Port Foster event - ensemble Hilbert spectrogram of IMF 1")}
}
\keyword{ts}
\keyword{hplot}
