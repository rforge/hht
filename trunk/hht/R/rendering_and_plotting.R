# Plotting and data analysis functions

ftspec_image <- function(sig, dt, ft, time_span = NULL, freq_span = NULL, amp_span = NULL, taper = 0.05, scaling = "none", grid=TRUE, colorbar=TRUE, backcol=c(0, 0, 0), colormap=NULL, pretty=TRUE, ...)
{
	#Plots a Fourier spectrogram
	#INPUTS
        #    SIG is the signal to analyze
        #    DT is the sample rate (must be constant)
	#    FT is the Fourier transform input parameters, adopted from Jonathan Lees' code in RSEIS
	#        FT$NFFT is the fft length
	#        FT$NS is the number of samples in a window
        #        FT$NOV is the number of samples to overlap
        #    TIME_SPAN is the time span to plot, NULL plots everything
        #    FREQ_SPAN is the frequency span to plot (<=max frequency in spectrogram), NULL plots everything up to the Nyquist frequency
	#    AMP_SPAN is the amplitude range to plot.  NULL plots everything.
        #    TAPER is the cosine taper factor (amount of the signal to apply the taper to, must be < 0.5)
        #    SCALING determines whether to apply a natural log (ln), logarithmic (log), or square root (sqrt) scaling to the amplitude data
        #    GRID is a boolean asking whether to display grid lines
        #    COLORBAR is a boolean asking whether to plot an amplitude colorbar
        #    BACKCOL is a 3 element vector of RGB values for the background of the spectrogram, based on a 0 to 255 scale: [red, green, blue]
        #    COLORMAP is an R palette object determining how the spectrogram colors should look
        #    PRETTY is a boolean asking whether to adjust axis labels so that they're pretty (TRUE) or give the exactly specified time and frequency intervals (FALSE)
        #    OPTIONAL PARAMETERS
        #       TRACE_FORMAT is the format of the trace minima and maxima in sprintf format
        #       IMG_X_FORMAT is the format of the X axis labels of the image in sprintf format
        #       IMG_Y_FORMAT is the format of the Y axis labels of the image in sprintf format
        #       COLORBAR_FORMAT is the format of the colorbar labels in sprintf format   
        #       CEX.LAB is the font size of the image axis labels
        #       CEX.COLORBAR is the font size of the colorbar
        #       CEX.TRACE is the font size of the trace axis labels
        #       IMG_X_LAB is the X - axis label of the image, it defaults to "time"
        #       IMG_Y_LAB is the Y - axis label of the image, it defaults to "frequency" 
        #OUTPUTS
        #    IMG is the spectrogram	
	opts = list(...)

        if(!"img_x_lab" %in% names(opts))
        {
            opts$img_x_lab = "time"
        }

        if(!"img_y_lab" %in% names(opts))
        {
            opts$img_y_lab = "frequency"
        }

        if(is.null(time_span))
        {
                time_span=c(dt, length(sig) * dt)
        }

        if(time_span[2] > length(sig) * dt)
        {
                time_span[2]= length(sig) * dt
                warning("The requested spectrogram is longer than the actual signal.")
        }

        if(is.null(freq_span))
        {
                freq_span=c(0, 1/(dt * 2))
        }
        if(freq_span[2] > 1 / (dt * 2))
        {
                freq_span[2] = 1 / (dt * 2)
                warning("Requested maximum frequency is higher than the Nyquist frequency.")
        }

	ev=evolutive_fft(sig, dt, ft, freq_span, taper) #Calculate the Fourier spectrogram
        ev$tt = seq(length(sig)) * dt

        if(is.null(amp_span))
        {    
             amp_span = c(min(ev$z), max(ev$z))
        }

        img = list()
        img$z = ev$z[ev$x >= time_span[1] & ev$x <= time_span[2], ev$y >= freq_span[1] & ev$y <= freq_span[2]]
        img$x = ev$x[ev$x >= time_span[1] & ev$x <= time_span[2]]
        img$y = ev$y[ev$y >= freq_span[1] & ev$y <= freq_span[2]]

        img$z[img$z<amp_span[1]] = NA
        img$z[img$z>amp_span[2]] = amp_span[2]
        img$z[img$z == 0] = NA

        if(scaling == "ln") #Scale by natural log
        {
            img$z = log(img$z)
        }

        if(scaling == "log") #Log 10 scale
        {
            img$z = log10(img$z)
        }

        if(scaling == "sqrt") #Take the square root
        {
            img$z = sqrt(img$z)
        }

        trace = list()
        trace$sig = ev$original_signal[ev$tt >= time_span[1] & ev$tt <= time_span[2]]
        trace$tt = ev$tt[ev$tt >= time_span[1] & ev$tt <= time_span[2]]

        hht_package_plotter(img, trace, opts$img_x_lab, opts$img_y_lab, window = ft$ns / length(sig), colormap = colormap, backcol = backcol, pretty = pretty, grid = grid, colorbar = colorbar, opts = opts)
 
        invisible(img)

}		

hh_render <- function(hres, dt, dfreq, freq_span = NULL, time_span = NULL, scaling = "none", verbose = TRUE)
{
	#Renders a spectrogram of EMD or Ensemble EMD (EEMD) results.
	#INPUTS
	#	HRES is a matrix of data generated by EEMD_COMPILE or the output of HHTRANSFORM
	#	it represents a set on all time/frequency/amplitude points from the given EEMD run
        #       DT is the time resolution of the spectrogram.  Currently, if there is a hres$dt field, DT must be greater than or equal to hres$dt.
        #       this prevents subsample resolution.
        #       DFREQ is the frequency resolution of the spectrogram
        #       FREQ_SPAN is the frequency range to calculate the spectrum over c(MIN, MAX).  NULL means capture the full frequency spectrum of the signal.
        #       TIME_SPAN is the portion of the signal to include.  NULL means the whole signal.
        #       SCALING determines whether to plot frequency as log 10 ("log") or linear ("none")
        #       VERBOSE prints out status messages (i.e. IMF 1 COMPLETE!)
	#OUTPUTS
	#	HGRAM is a spectrogram matrix ready to be plotted by HHGRAM_IMAGE
	#Danny Bowman
	#UNC Chapel Hill

        hgram = hres

        if(scaling == "log")
        {
            hres$hinstfreq = log10(hres$hinstfreq)
        }
        else if (scaling != "none")
        {
             warning("Did not recognize scaling request \"", scaling, ".\" Reverting to linear frequency (scaling = \"none\").")
        }
       
        #Deal with logarithms of 0
        hres$hamp[hres$hinstfreq == -Inf] = 0
        hres$hinstfreq[hres$hinstfreq == -Inf] = 0

        if(is.null(freq_span))
        {
             freq_span = c(min(hres$hinstfreq), max(hres$hinstfreq))
        }
	
        if(!"trials" %in% names(hres))
 	{
		hres$trials=1
	}
        
        if("dt" %in% names(hres))
        {
             if(hres$dt > dt) #We don't want to have to interpolate between samples
             {
                 warning(paste("The time resolution", sprintf("%.2e", dt), "is lower than the sample rate", sprintf("%.2e", hres$dt), "of the time series.  This may introduce time gaps in the spectrogram."))
             }
             if("tt" %in% names(hres))
             {
                 warning("Input data has both DT (sample rate) and TT (sample times) components.  Component TT will be used to calculate the spectrogram")
                 hgram$tt = hres$tt
             }
             else
             {
                 hgram$tt = seq(length(hres$original_signal)) * hres$dt
             }
        }

        if(is.null(time_span))
        {
           time_span = c(min(hgram$tt), max(hgram$tt))
        }

        if(!(("tt" %in% names(hres)) | ("dt" %in% names(hres))))
        {
            warning("Neither DT (sample rate) nor TT (sample times) were specified in the input data.  Assuming DT is 1...")
            hgram$tt = seq(length(hres$original_signal))
        } 

        if(time_span[2]>max(hgram$tt))
        {
                time_span[2]=max(hgram$tt)
                warning("Requested time window is longer than the actual signal.")
        }
 
        hres$hinstfreq = array(hres$hinstfreq[which(hgram$tt >= time_span[1] & hgram$tt <= time_span[2]),], dim = c(length(hgram$tt), hres$nimf, hres$trials))
        hres$hamp = array(hres$hamp[hgram$tt >= time_span[1] & hgram$tt <= time_span[2],], dim = c(length(hgram$tt), hres$nimf, hres$trials))
        hres$original_signal = hres$original_signal[hgram$tt >= time_span[1] & hgram$tt <= time_span[2]]
        hgram$tt = hgram$tt[hgram$tt >= time_span[1] & hgram$tt <= time_span[2]]
       
        grid = list()
        grid$x = hgram$tt
        grid$y = seq(from = freq_span[1], to = freq_span[2] + dfreq, by = dfreq)
        hgram$z=array(rep(0,(length(grid$x) * length(grid$y) * hres$nimf)),dim=c(length(grid$x),length(grid$y), hres$nimf))
        hgram$cluster=hgram$z #Shows how many times a given grid node has data.
        for(i in seq(hres$nimf))
        {
            x = array(c(rep(hgram$tt,hres$trials), hres$hinstfreq[,i,]), dim = c(length(hgram$tt)*hres$trials, 2))
            imf_img = as.image(hres$hamp[,i,], grid = grid, x = x)
            hgram$z[,,i] = imf_img$z
            hgram$cluster[,,i] = imf_img$weights
            if(verbose)
            {
                print(paste("IMF", i, "COMPLETE!"))
            }
        }
       
        hgram$hinstfreq = hres$hinstfreq
        hgram$hamp = hres$hamp 
        hgram$z[is.na(hgram$z)] = 0
        hgram$cluster[is.na(hgram$cluster)] = 0
        hgram$x = imf_img$x 
        hgram$y = imf_img$y
	hgram$dfreq=dfreq
	hgram$dt=hres$dt
        hgram$scaling = scaling
	invisible(hgram) #Return the spectrogram structure.
}

hh_spectrum <- function(hres, dt, dfreq, freq_span = NULL, time_span = NULL, scaling = "none", verbose = TRUE)
{
    #Calculate the Hilbert spectrogram of a signal contained in HRES (returned by HHTRANSFORM or EEMD_COMPILE)
    #INPUTS
    #       HRES is a matrix of data generated by EEMD_COMPILE or the output of HHTRANSFORM
    #       it represents a set on all time/frequency/amplitude points from the given EEMD run
    #       DT is the time resolution of the spectrogram.  Currently, if there is a hres$dt field, DT must be greater than or equal to hres$dt.
    #       this prevents subsample resolution.
    #       DFREQ is the frequency resolution of the spectrogram
    #       FREQ_SPAN is the frequency range to calculate the spectrum over c(MIN, MAX).  NULL means capture the full frequency spectrum of the signal.
    #       TIME_SPAN is the time span to calculate the spectrum over c(MIN, MAX).  NULL means use the entire signal
    #       SCALING determines whether to calculate frequency as log 10 ("log") or linear ("none")
    #       VERBOSE prints out status messages (i.e. IMF 1 COMPLETE!)
    #OUTPUTS
    #    HSPEC is the Hilbert spectrum of the signal, separated by IMF.

   hgram = hh_render(hres, dt, dfreq, freq_span = NULL, time_span = NULL, scaling = scaling, verbose = TRUE)

   amps = array(rep(0, dim(hgram$z)[2] * dim(hgram$z)[3]), dim = dim(hgram$z)[2:3])

   for(i in seq(hres$nimf))
   {
       amps[, i] = apply(hgram$z[, , i], 2, sum) 
   }

  invisible(list(amplitude = amps, frequency = hgram$y, original_signal = hgram$original_signal, dt = hgram$dt))
} 

hhgram_image <- function(hgram,time_span = NULL,freq_span = NULL, amp_span = NULL, clusterspec = FALSE, cluster_span=NULL, imf_list = NULL, imf_sum = FALSE, scaling = "none", grid=TRUE, colorbar=TRUE, backcol=c(0, 0, 0), colormap=NULL, pretty=FALSE, ...)
{
	#Plots a spectrogram of the EEMD processed signal as an image.	
	#INPUTS
	#	HGRAM is the subsetted spectrogram  from HH_RENDER.
	#		HGRAM$X is time
	#		HGRAM$Y is frequency
	#		HGRAM$Z is amplitude normalized to trials
	#		HGRAM$CLUSTER is a matrix containing integer values corresponding to the number of times a signal was recorded in a given spectrogram cell during EEMD
	#		The more often the signal is recorded, the more likely it is that the signal is real and not noise
	#		HGRAM$TRIALS is the number of times EEMD was run to generate signal
	#		HGRAM$ORIGINAL_SIGNAL is the original seismogram (without added noise)
        #               HGRAM$TT is the sample times
	#	TIME_SPAN is the time span to plot, [0,-1] plots everything
	#	FREQ_SPAN is the frequency span to plot (<=max frequency in spectrogram), [0,-1] plots everything
	#	AMP_SPAN is the amplitude span to plot, everything below is set to black, everything above is set to max color, [0, -1] scales to range in signal
        #	CLUSTERSPEC tells the code to plot the signal amplitude (FALSE) or the number of times data occupies a given pixel (TRUE).
	#	CLUSTER_SPAN plots only the parts of the signal that have a certain number of data points per pixel [AT LEAST, AT MOST] this only applies to EEMD with multiple trials.
        #       IMF_LIST is a list of IMFs to plot on the spectrogram.  If NULL, plot all IMFs.
        #       IMF_SUM can be set to show the sum of IMFs shown in the spectrogram plotted as a red line against the original trace
        #       SCALING determines whether to apply a logarithmic (log), or square root (sqrt) scaling to the amplitude data, default is "none"
	#	GRID is a boolean asking whether to display grid lines
	#	COLORBAR is a boolean asking whether to plot an amplitude colorbar
        #       BACKCOL is a 3 element vector of RGB values for the background of the spectrogram, based on a 0 to 255 scale: [red, green, blue]
        #       COLORMAP is an R palette object determining how the spectrogram colors should look
        #       PRETTY is a boolean asking whether to adjust axis labels so that they're pretty (TRUE) or give the exactly specified time and frequency intervals (FALSE)
	#OPTIONAL PARAMETERS
        #       TRACE_FORMAT is the format of the trace minima and maxima in sprintf format
        #       IMG_X_FORMAT is the format of the X axis labels of the image in sprintf format
        #       IMG_Y_FORMAT is the format of the Y axis labels of the image in sprintf format
        #       COLORBAR_FORMAT is the format of the colorbar labels in sprintf format   
        #       CEX.LAB is the font size of the image axis labels
        #       CEX.COLORBAR is the font size of the colorbar
        #       CEX.TRACE is the font size of the trace axis labels
        #       IMG_X_LAB is the X - axis label of the image, it defaults to "time"
        #       IMG_Y_LAB is the Y - axis label of the image, it defaults to "frequency"
        #OUTPUTS
        #     IMG is the spectrogram returned as an image

        opts = list(...)
 
        if(!"img_x_lab" %in% names(opts))
        {
            opts$img_x_lab = "time"
        }
        
        if(!"img_y_lab" %in% names(opts))
        {
            opts$img_y_lab = "frequency"
        }
  
        #Subset by IMFs
        if(is.null(imf_list))
        {
            imf_list = seq(hgram$nimf)
        }
        else
        {
            if(max(imf_list) > hgram$nimf)
            {
                warning("Requested more IMFs than are present in the actual EMD results!")
                imf_list = imf_list[imf_list < hgram$nimf]
            }
        }   
   
        if(!is.null(cluster_span))
        {
            img$z[cluster >= cluster_span[1] & cluster <= cluster_span[2]] = NA
        } 
 
	if(is.null(time_span))
	{
		time_span=c(min(hgram$tt), max(hgram$tt))
	}
	
	if(time_span[2]>max(hgram$tt))
	{
		time_span[2]=max(hgram$tt)
		warning("Requested time window is longer than the actual signal.")
	}
	
	if(is.null(freq_span))
	{
		freq_span=c(min(hgram$y), max(hgram$y))
	}
	if(freq_span[2]>max(hgram$hinstfreq))
	{
		freq_span[2]=max(hgram$y)
		warning("Requested frequency window is higher than maximum frequency in the spectrogram.")
	}

        if(imf_sum)
        {
             imf_sum = rowSums(hgram$averaged_imfs[hgram$x >= time_span[1] & hgram$x <= time_span[2], imf_list])
        }
        else
        {
            imf_sum = NULL
        }

        img = list()
        img$x = hgram$x[hgram$x >= time_span[1] & hgram$x <= time_span[2]]
        img$y = hgram$y[hgram$y >= freq_span[1] & hgram$y <= freq_span[2]]
        cluster = apply(hgram$cluster[hgram$x >= time_span[1] & hgram$x <= time_span[2], hgram$y >= freq_span[1] & hgram$y <= freq_span[2],imf_list], c(1, 2), sum)

        #Determine if we are plotting clustering or amplitudes

        if(clusterspec)
        {
            img$z = cluster
        }
        else
        {
            img$z = apply(hgram$z[hgram$x >= time_span[1] & hgram$x <= time_span[2], hgram$y >= freq_span[1] & hgram$y <= freq_span[2],imf_list], c(1, 2), sum)
        }

        if(!is.null(cluster_span))
        {
            img$z[cluster <= cluster_span[1] |  cluster >= cluster_span[2]] = NA
        }
       

        if(is.null(amp_span))
        {
             amp_span = c(min(img$z), max(img$z))
        }
 
        img$z[img$z<amp_span[1]] = NA
        img$z[img$z>amp_span[2]] = amp_span[2]
        img$z[img$z == 0] = NA

        if(scaling == "log") #Log 10 scale
        {
            img$z = log10(img$z) 
        }
   
        if(scaling == "sqrt") #Take the square root
        {
            img$z = sqrt(img$z)
        }
       
        trace = list()
        trace$sig = hgram$original_signal[hgram$tt >= time_span[1] & hgram$tt <= time_span[2]]
        trace$tt = hgram$tt[hgram$tt >= time_span[1] & hgram$tt <= time_span[2]]

        hht_package_plotter(img, trace, opts$img_x_lab, opts$img_y_lab, imf_sum = imf_sum, colormap = colormap, backcol = backcol, pretty = pretty, grid = grid, colorbar = colorbar, opts = opts)
    
        invisible(img)
}

hhspec_plot <- function(hspec, freq_span = NULL, scaling = "none", imf_list = NULL, show_total = TRUE, show_fourier = FALSE, show_imfs = FALSE, legend = TRUE, ...)
{
    #Plot the Hilbert spectrum, optionally as individual IMFs, optionally with the scaled Fourier spectrum for comparison
    #INPUTS
    #    HSPEC is the Hilbert spectrogram returned by HHSPECTRUM
    #    FREQ_SPAN is the frequencies to plot, NULL means plot everything
    #    SCALING whether to take the base 10 logarithm of amplitude ("log") or square root of amplitude ("sqrt")  or do nothing ("none")
    #    IMF_LIST means only include these IMFS, NULL includes all of them
    #    SHOW_TOTAL means show the sum of the IMF Hilbert spectra
    #    SHOW_IMFS means plot individual IMFs
    #    SHOW_FOURIER determines whether you want a Fourier spectrum for comparison (TRUE) or not (FALSE)
    #    IMF_COLS is a vector of length IMF_LIST with colors to plot the individual IMFs.  Defaults to a colormap
    #    LEGEND asks whether to plot a legend.  Additional options will place the legend where you want it.
    #ADDITIONAL OPTIONS
    #    XLAB is the X axis label
    #    YLAB is the Y axis label
    #    LEGEND_LOCATION determines where to put the legend.
    #    TOTAL_COL is the color of the ensemble Hilbert spectrum
    #    TOTAL_LWD is the line weight of the ensemble Hilbert spectrogram
    #    LOTAL_LTY is the line type of the ensemble Hilbert spectrogram
    #    IMF_COLS sets the color of each IMF - a vector with length IMF_LIST    
    #    IMF_LWD is the line weight for the IMFs as a vector with length IMF_LIST
    #    IMF_LTY is the line type for the IMFs as a vector with length IMF_LIST
    #    FOURIER_COL is the color of the Fourier spectrum line
    #    FOURIER_LTY is the line type of the Fourier spectrum line
    #    FOURIER_LWD is the line weight of the Fourier spectrum line
    #    SCALE_FOURIER scales the Fourier spectrum line to the Hilbert spectrum line if TRUE.  Defaults to FALSE.

    if(!(show_total | show_imfs | show_fourier))
    {
        error("Nothing to plot!  Set at least one of SHOW_TOTAL, SHOW_IMFS, or SHOW_FOURIER to TRUE.")
    }

    opts = list(...)

    if(!(scaling == "log" | scaling == "sqrt" | scaling == "none"))
    {
        warning(paste("Did not recognize requested scaling: \"", scaling, "\".  Options are \"log\" (base 10 logarithm), \"sqrt\" (square root), or \"none\""))
        scaling = "none"
    }
    
    if(is.null(freq_span))
    {
        freq_span = c(0, max(hspec$frequency))
    }
   
    hspec$amplitude = hspec$amplitude[hspec$frequency >= freq_span[1] & hspec$frequency<= freq_span[2],]
    hspec$frequency = hspec$frequency[hspec$frequency >= freq_span[1] & hspec$frequency<= freq_span[2]]

    if(!"legend_location" %in% names(opts) & legend)
    {
        opts$legend_location = "topright"
    }


    if(!"total_col" %in% names(opts))
    {
        opts$total_col = "red"
    }

    if(!"total_lwd" %in% names(opts))
    {
        opts$total_lwd = 1
    }
    
    if(!"total_lty" %in% names(opts))
    {
        opts$total_lty = 1
    }

    if(!"xlab" %in% names(opts))
    {
        opts$xlab = "frequency"
    }

    if(!"ylab" %in% names(opts))
    {
        if(scaling != "none")
        {
            opts$ylab = paste(scaling, "amplitude")
        }
        else
        {
             opts$ylab = "amplitude"
        }
    }
    
    if(is.null(imf_list))
    {
        imf_list = seq(dim(hspec$amplitude)[2])
    }

    if(!"imf_cols" %in% names(opts))
    {
        if(show_total)
        {
            opts$imf_cols = rainbow(length(imf_list), start = 1/6, end = 5/6)
        }
        else
        {
            opts$imf_cols = rainbow(length(imf_list), start = 0, end = 5/6)
        }
    }
   
    if(!"imf_lwd" %in% names(opts))
    {
        opts$imf_lwd = rep(1, length(imf_list))
    }

    if(!"imf_lty" %in% names(opts))
    {
        opts$imf_lty = rep(1, length(imf_list))
    }

    if(!"fourier_col" %in% names(opts))
    {
        opts$fourier_col = "black"
    }

    if(!"fourier_lty" %in% names(opts))
    {
        opts$fourier_lty = 1
    }
   
    if(!"fourier_lwd" %in% names(opts))
    {
        opts$fourier_lwd = 1
    }

    if(!"scale_fourier" %in% names(opts))
    {
        opts$scale_fourier = FALSE
    }
    
    pmin = Inf
    pmax = -Inf

    if(show_imfs)
    {
        imf_amp = hspec$amplitude[, imf_list]
        pmin = min(imf_amp[imf_amp>0])
        pmax = max(imf_amp)
    }

    if(show_total)
    {
        if(length(imf_list)>1)
        {
            total_amp = apply(hspec$amplitude[,imf_list], 1, sum)
        }
        else
        {
            total_amp = hspec$amplitude[,imf_list]
        }
        if(max(total_amp) > pmax)
        {
            pmax = max(total_amp[total_amp > 0])
        }
        if(min(total_amp) < pmin)
        {
            pmin = min(total_amp[total_amp > 0])
        }
    }

     if(show_fourier)
     {
        fourier_freqs = seq(0, 1/(hspec$dt * 2), length.out = length(hspec$original_signal)-1)
        fspec = Mod(fft(hspec$original_signal - mean(hspec$original_signal)))[1:length(hspec$original_signal)/2][fourier_freqs >= freq_span[1] & fourier_freqs <= freq_span[2]]
        if(opts$scale_fourier)
        {
            fspec = fspec * pmax/max(fspec)
        }
        if(max(fspec) > pmax)
        {
            pmax = max(fspec)
        }
        if(min(fspec[fspec > 0]) < pmin)
        {
            pmin = min(fspec[fspec > 0])
        }
    }
    
    if(scaling == "log")
    {
        pmax = log10(pmax)
        pmin = log10(pmin)
    }

    if(scaling == "sqrt")
    {
        pmax = sqrt(pmax)
        pmin = sqrt(pmin)
    }
    
    plot(c(min(hspec$frequency), max(hspec$frequency)), c(pmin, pmax), type = "n", xlab = opts$xlab, ylab = opts$ylab)

    if(show_imfs)
    {
       for(k in seq(length(imf_list)))
       {

           amp = imf_amp[,k]
           if(scaling == "log")
           {
              amp = log10(amp)
           }

           if(scaling == "sqrt")
           {
               amp = sqrt(amp)
           } 
           lines(hspec$frequency[amp > -Inf], amp[amp > -Inf], col = opts$imf_cols[k], lwd = opts$imf_lwd[k], lty = opts$imf_lty[k])
       }
    }
   
    if(show_total) 
    {
        if(scaling == "log")
        {
            total_amp = log10(total_amp)
        }

        if(scaling == "sqrt")
        {
            total_amp = sqrt(total_amp)
        }

        lines(hspec$frequency, total_amp, lwd = opts$total_lwd, lty = opts$total_lty, col = opts$total_col)
    }

    if(show_fourier)
    {

        if(scaling == "log")
        {
            fspec = log10(fspec)
        }

        if(scaling == "sqrt")
        {
            fspec = sqrt(fspec)
        }

        lines(fourier_freqs[fourier_freqs >= freq_span[1] & fourier_freqs <= freq_span[2]], fspec, 
            lty = opts$fourier_lty, lwd = opts$fourier_lwd, col = opts$fourier_col)
    }

    if(legend)
    {
        legend_labs = c()
        legend_cols = c()
        legend_lty = c()
        legend_lwd = c()
        if(show_total)
        {
            legend_labs = c(legend_labs, "Total Hilbert")
            legend_cols = c(legend_cols, opts$total_col)
            legend_lty = c(legend_lty, opts$total_lty)
            legend_lwd = c(legend_lwd, opts$total_lwd) 
        }
        if(show_imfs) 
        {
            legend_labs = c(legend_labs, paste(rep("IMF", length(imf_list)), imf_list))
            legend_cols = c(legend_cols, opts$imf_cols)
            legend_lty = c(legend_lty, opts$imf_lty)
            legend_lwd = c(legend_lwd, opts$imf_lwd)
        }

        if(show_fourier)
        {
            legend_labs = c(legend_labs, "Fourier")
            legend_cols = c(legend_cols, opts$fourier_col)
            legend_lty = c(legend_lty, opts$fourier_lty[1])
            legend_lwd = c(legend_lwd, opts$fourier_lwd[1])
        }
        legend(opts$legend_location, legend = legend_labs, lty = legend_lty, lwd = legend_lwd, col = legend_cols)
     }
}



hht_package_plotter <- function(img, trace, img_x_lab, img_y_lab, imf_sum = NULL, window = NULL, colormap = NULL, backcol = c(0, 0, 0), pretty = FALSE, grid = TRUE, colorbar = TRUE, opts = list())
{
    #Plots images and time series for Hilbert spectra, Fourier spectra, and cluster analysis.
    #This function is internal to the package and users should not be calling it.
    #
    #INPUTS
    #    IMG is the image portion of the figure
    #        IMG$X is the columns
    #        IMG$Y is the rows
    #        IMG$Z is the image data
    #    TRACE is the time series to plot at the top of the figure
    #        TRACE$SIG is the time series
    #        TRACE$TT is the time of each sample
    #    IMG_X_LAB is the label of the X axis of the image
    #    IMG_Y_LAB is the label of the Y axis of the image
    #    IMF_SUM is a red line on the time series plot showing the sum of the plotted IMFs, if available
    #        IMF_SUM$SIG is the summed IMFS
    #        IMF_SUM$TT is the time of each sample.  We assume all IMFS have equivalent timing.
    #    WINDOW is the length of the Fourier window, if applicable
    #    COLORMAP is the colormap to use for the image
    #    BACKCOL is the background color of the image
    #    PRETTY allows for nice axis labels
    #    GRID draws a grid on the image
    #    COLORBAR puts a colorbar corresponding to the range of values on the image
    #
    #    OPTS    OTHER POSSIBLE OPTIONS
    #        OPTS$TRACE_FORMAT is the format of the trace minima and maxima in sprintf format
    #        OPTS$IMG_X_FORMAT is the format of the X axis labels of the image in sprintf format
    #        OPTS$IMG_Y_FORMAT is the format of the Y axis labels of the image in sprintf format
    #        OPTS$COLORBAR_FORMAT is the format of the colorbar labels in sprintf format   
    #        OPTS$CEX.LAB is the font size of the image axis labels
    #        OPTS$CEX.COLORBAR is the font size of the colorbar
    #        OPTS$CEX.TRACE is the font size of the trace axis labels
    #        OPTS$TRACE_COL is the color of the trace
    #        OPTS$IMF_SUM_COL is the color of the IMF sums (if shown)

    #Configure parameters
    
    if(!"trace_format" %in% names(opts))
    {
        opts$trace_format = "%.1e"
    }
 
    if(!"img_x_format" %in% names(opts))
    {
        opts$img_x_format = "%.2f"
    }
   
    if(!"img_y_format" %in% names(opts))
    {
        opts$img_y_format = "%.2f"  
    }
  
    if(!"colorbar_format" %in% names(opts))
    {
         opts$colorbar_format = "%.1e"
    }
 
    if(!"cex.main" %in% names(opts))
    {
        opts$cex.main = 1
    }
    
    if(!"cex.trace" %in% names(opts))
    {
        opts$cex.trace = opts$cex.main * 0.75
    }

    if(!"cex.colorbar" %in% names(opts))
    {
        opts$cex.colorbar = opts$cex.main * 0.75
    }

    if(!"cex.lab" %in% names(opts))
    {
        opts$cex.lab = opts$cex.main
    }

    if(!"imf_sum_col" %in% names(opts))
    {
        opts$imf_sum_col = "red"
    }
   
    if(!"trace_col" %in% names(opts))
    {
        opts$trace_col = "black"
    }

    if(pretty)
    {   #Get nice divisions
        pretty_x = pretty(img$x, n=10)
        pretty_y = pretty(img$y, n=5) 
        pretty_x = pretty_x[pretty_x <= max(img$x) & pretty_x >= min(img$x)]
        pretty_y = pretty_y[pretty_y <= max(img$y) & pretty_y >= min(img$y)]
        img$z = img$z[img$x <= max(pretty_x) & img$x >= min(pretty_x), img$y <= max(pretty_y) & img$y >= min(pretty_y)]
        img$x = img$x[img$x <= max(pretty_x) & img$x >= min(pretty_x)]
        img$y = img$y[img$y <= max(pretty_y) & img$y >= min(pretty_y)]
        img_x_labels=sprintf(opts$img_x_format, pretty_x)
        img_y_labels=sprintf(opts$img_y_format, pretty_y)
        cat("Adjusting Time and Frequency limits to nice looking numbers (the \"pretty\" option is currently set to TRUE)\n")
    }    
    else 
    {    
       img_x_labels=sprintf(opts$img_x_format, seq(min(img$x), max(img$x), length.out = 10))
       img_y_labels=sprintf(opts$img_y_format, seq(min(img$y), max(img$y), length.out=5))
    }    

    if(is.null(colormap))
    {
        colormap=rainbow(500,start=0,end=5/6)
    }

    colorbins = length(colormap)
    
    plot(c(-0.15,1),c(-0.15,1),type="n",axes=FALSE,xlab="", ylab="") # Set up main plot window
 
    #Plot TRACE

    sig = trace$sig - mean(trace$sig)
    trace_y=0.75
    trace_x=0
    trace_yspan=0.10
    trace_xspan=0.9
    trace_at=seq(trace_y,trace_y+trace_yspan,length.out=2)
    trace_labels=c(min(trace$sig), max(trace$sig))
    trace_scale=trace_yspan/(max(sig)-min(sig))
    tt_scale=trace_xspan/(max(trace$tt) - min(trace$tt))
    axis(4,pos=trace_x+trace_xspan,at=trace_at, labels=c("",""), cex.axis=opts$cex.trace)
    lines((trace$tt - min(trace$tt)) * tt_scale + trace_x, trace_y + (sig - min(sig)) * trace_scale, col = opts$trace_col)
    if(!is.null(imf_sum))
    {
         lines(((trace$tt - min(trace$tt))*tt_scale+trace_x), (trace_y + (imf_sum - min(sig)) * trace_scale), col = opts$imf_sum_col)
    }
    rect(trace_x, trace_y, trace_x+trace_xspan, trace_y+trace_yspan)

    #Plot IMAGE
    
    image_y=0
    image_x=0
    image_yspan=0.75
    image_xspan=0.9
    image_xvec=seq(image_x, image_x+image_xspan, length.out=length(img$x))
    image_yvec=seq(image_y, image_y+image_yspan, length.out=length(img$y))
    img_x_at=seq(image_x,image_x+image_xspan,length.out=length(img_x_labels))
    img_y_at=seq(image_y,image_y+image_yspan, length.out=length(img_y_labels))
    rect(image_x,image_y,image_x+image_xspan,image_y+image_yspan,col=rgb(red=backcol[1], green=backcol[2], blue=backcol[3], maxColorValue=255))
    image(image_xvec,image_yvec, img$z, col=colormap,add=TRUE)
    axis(2, pos=image_x, at=img_y_at,labels=img_y_labels, cex.axis=opts$cex.lab)
    axis(1,pos=image_y, at=img_x_at,labels=img_x_labels, cex.axis=opts$cex.lab)

    #Plot Fourier window, if applicable
    
    if(!is.null(window))
    {
        rwidth = trace_xspan * window 
        rect(trace_x + trace_xspan - rwidth, trace_y + trace_yspan, trace_x + trace_xspan, trace_y + trace_yspan + 0.01, col = "black")
    }


    #Plot GRID
    if(grid)
    {
        line_color=rgb(red=100, green=100, blue=100, maxColorValue=255)
        line_type=3
        for(k in 2:(length(img_x_at)-1))
        {
            lines(c(img_x_at[k], img_x_at[k]), c(image_y, trace_y+trace_yspan), col=line_color, lty=line_type)
        }

        for(k in 2:(length(img_y_at)-1))
        {
            lines(c(image_x, image_x+image_xspan), c(img_y_at[k], img_y_at[k]), col=line_color, lty=line_type)
        }
    }

    #Plot COLORBAR

    if(colorbar)
    {
        color_x=image_x+image_xspan+0.015
        color_xspan=0.025
        color_y=image_y+image_yspan-0.20
        color_yspan=0.10
        color_xvec=c(color_x,color_x+color_xspan)
        color_yvec=seq(color_y, color_y+color_yspan, length.out=colorbins)
        color_at=seq(color_y,color_y+color_yspan,length.out=2)
        colorbar_matrix=array(seq_len(colorbins),dim=c(1, colorbins))
        image(color_xvec, color_yvec, colorbar_matrix, col=colormap, axes=FALSE, add=TRUE)
    }


    #Plot TEXT


    text(trace_x + trace_xspan + 0.03, trace_y, srt=90, sprintf(opts$trace_format,trace_labels[1]), cex=opts$cex.trace)
    text(trace_x + trace_xspan + 0.03, trace_y+trace_yspan, srt=90, sprintf(opts$trace_format, trace_labels[2]), cex=opts$cex.trace)
    text(image_x-0.095, image_y+image_yspan/2, srt=90, img_y_lab, cex=opts$cex.lab)
    text(image_x+image_xspan/2, image_y-0.1, img_x_lab, cex=opts$cex.lab)
    if("main" %in% names(opts))
    {
        text(trace_x+trace_xspan/2, trace_y+trace_yspan+0.05,opts$main, cex=opts$cex.main)
    }
    if(colorbar)
    {
        text(color_x+0.015, color_y-0.0125, sprintf(opts$colorbar_format, min(img$z[!is.na(img$z)])), cex=opts$cex.colorbar)
        text(color_x+0.015, color_y+color_yspan+0.0125, sprintf(opts$colorbar_format, max(img$z[!is.na(img$z)])), cex=opts$cex.colorbar)
    }
 
}

plot_imfs <-function(sig, time_span, imf_list, original_signal, residue, fit_line=FALSE, lwd=1, cex=1, ...)
{
    #Better IMF plotter
    #This function plots IMFs on the same plot so they can be checked for mode mixing or other problems.
    #It plots shifted traces in a single window
    #INPUTS
    #    SIG is the signal data structure returned by EEMD or EMD analysis
    #    Note that SIG$AVERAGED_IMFS will be plotted instead of SIG$IMF, likewise SIG$AVERAGED_RESIDUE takes precidence
    #    over SIG$RESIDUE, if both exist.
    #        SIG$IMF is a N by M array where N is the length of the signal and M is the number of IMFs
    #        SIG$ORIGINAL_SIGNAL is the original signal before EEMD
    #        SIG$RESIDUE is the residual after EMD
    #        SIG$DT is the sample rate
    #    TIME_SPAN is a 2 element vector giving the time range to plot
    #    IMF_LIST is the IMFs to plot
    #    ORIGINAL_SIGNAL is a boolean asking if you are going to plot the original signal also (defaults to be on top)
    #    RESIDUE is a boolean asking if you are going to plot the residual (defaults to be on bottom)
    #	 FIT_LINE is a boolean asking if you want to plot a line showing the sum of IMFs on top of the original signal (to check how the selected IMFs reconstruct the original signal)
    #	 LWT is the line weight (for plotting figures)
    #    CEX is the size of text (for plotting figures)
    #    ... other parameters to pass to main plotting function
   
 
    if(time_span[2]<0)
    {
        time_span[2]=length(sig$original_signal)*sig$dt
    }
    
    if(time_span[1]==0)
    {
        time_span[1]=sig$dt
    }
    
    if("averaged_imfs" %in% names(sig))
    {
        sig$imf=sig$averaged_imfs
    }

    if("averaged_residue" %in% names(sig))
    {
        sig$residue=sig$averaged_residue
    }


    time_ind=ceiling(time_span[1]/sig$dt):floor(time_span[2]/sig$dt)
    tt=time_ind*sig$dt
    
    plot(c(0, 1), c(0, 1), type="n", axes=FALSE, xlab="Time (s)", ylab="", cex.lab=cex, ...)
    
    yax_labs=c()
    snum=length(imf_list)+residue+original_signal
    sp=1/snum # Spacing of subplots

    if(original_signal)
    {
         snum=snum+1
         os=sig$original_signal[time_ind]-mean(sig$original_signal[time_ind])
         scale=max(abs(os)) 
    }
    else
    {
        scale=max(abs(sig$imf))
    }
    
    if(residue)
    {
        snum=snum+1
        res=sig$residue[time_ind]-mean(sig$residue[time_ind])
	res=res*(sp/(2*scale))
        yax_labs=append(yax_labs,"Residue")
    }

    
    trace_pos=sp/2 #Where the trace starts on the plot
    imfs=sig$imf*(sp/(scale*2))
    ts=(tt-min(tt))*(1/(time_span[2]-time_span[1]))

    if(residue)
    {
        lines(ts, res+trace_pos, lwd=lwd)
        trace_pos=trace_pos+sp
    } 
    
    for(k in rev(imf_list))
    {
       lines(ts, imfs[time_ind,k]+trace_pos, lwd=lwd)
       trace_pos=trace_pos+sp
       yax_labs=append(yax_labs, paste("IMF",k))
    }
    if(original_signal)
    {
        lines(ts, os*(sp/(2*scale))+trace_pos, lwd=lwd)
        yax_labs=append(yax_labs,"Signal")
        if(fit_line)
        {
            if(length(imf_list)>1)
            {
                fline=rowSums(imfs[time_ind,imf_list])
            }
            else
            {
                fline=imfs[time_ind,imf_list]
            }
            if(residue)
            {
                fline=fline+res
            }
            lines(ts, fline+trace_pos, lwd=lwd, col="red")
        }
    }
    xax_labs=pretty(seq(min(tt)-sig$dt, max(tt), length.out=11))
    axis(1, pos=0, at=seq(0,1, length.out=length(xax_labs)), labels=xax_labs, cex.axis=cex)
    axis(2, pos=0, at=seq(sp/2, 1, by=sp), labels=yax_labs, cex.axis=cex)
    segments(c(0,0,1, 0), c(0, 1, 1, 0), c(0,1, 1, 1), c(1,1, 0, 0), lwd=lwd) 
}
